1. What is a deadlock in trading? 
2. What is the wait-for graph? 
represent a dependencies between threads.
node - therads 
edges _ threads a is waition for a lock b owns

3. How to identify deadlock usingthat graph? 
there are contain a cycle it has deadlock.

4. What are the techniques for avoiding deadlocks? 

Lock ordering 
avoiding netsed locks
deadlocks detection
lock hierarchies


5. Can this cause a deadlock? if so how?
public class BankAccount {
	private long balance;

	public BankAccount(long balance) {
		this.balance = balance;
	}
	
	static synchronized void transferFrom(BankAccount source,
		BankAccount dest, long amount) {
			source.balance -= amount;
			dest.balance += amount
	}

}

No , it doesnt chance to be deadlock because this method is declared static synchronized, 
it mean it lock the class level , so only one thread can access at a time. 

--------------------------------------------------------------------------------

6. Can this cause a deadlock? if so how?
public class BankAccount {
	private long balance;

	public BankAccount(long balance) {
		this.balance = balance;
	}
	
	static synchronized void transferFrom(BankAccount source,
		BankAccount dest, long amount) {

		synchronized(source){
			synchronized(dest){
				source.balance -= amount;
				dest.balance += amount
			}
		}
	}
}
yes , this cause to be a deadlock, because when bankaccount have 2 sharedaboject like A and B techniques
thead 1 is transfer from A to B then thread 2 transefer from B to A . when both threads are execute and thread 1 start from A and thread 2 start from B 
 but to continue executtion  thread 1 want b and thread 2 want A. so therad 1 wait for B and thread 2 wait to get A. 
 in this situation call deadlock.
thread 1 and thread 2 blocked forever and wating for each other.

--------------------------------------------------------------------------------------------------

7. Can this cause a deaklock? if so how?
public class BankAccount {
	private long balance;

	public BankAccount(long balance) {
		this.balance = balance;
	}
	
	static synchronized void transferFrom(BankAccount source,
		BankAccount dest, long amount) {
			source.balance -= amount;
			dest.balance += amount
	}

	public synchronized long balance() {
		return balance;
	}
}
 no , this is not chnase to be a deadlock , because transferFrom is a static synchronized
 method so it lock a class level lock. 

 and balance is the instance method with synchronized it locks on the individual BankAccount instance

 ------------------------------------------------------------------------------------



8. what does do @ThreadSafe, @NotThreadSafe,  @GuardedBy and @Immutable annotaion do? Do they change behaviour of the program?

@ThreadSafe : class or methods that are design to be thread safe 

@NotThreadSafe : not design to be thread safe

@GuardedBy : annotated filed or methods must only be accessed when holding the specifield lock.
@Immutable : marks classe  is Immutable, their state cant be modify.


9. Avoid the deadlock by following program, uring ordering?

public class BankAccount {
	private long balance;
	private final long id = SerialNumber.generateSerialNumber();

	public BankAccount(long balance) {
		this.balance = balance;
	}
	
	static  void transferFrom(BankAccount source,
		BankAccount dest, long amount) {
			BankAccount first = source.id < dest.id ? source : dest 
			BankAccount second = second == first ? dest : source
		

		synchronized(first){
			synchronized(second){
				source.balance -= amount;
				dest.balance += amount
			}
		}
	}
}

10. What is the advantage of using private lock?
it helps to hide lock from external classes

11. What is the wait() and notify() do? give a example?
wait() is used to to release the lock of object and another thread can access that object.

notify () is use to nofify other threads and wokes up 
a single thread is already in wating state.

12. What is the difference between wait and sleep?

wait () : should call to object class
		release the lock it holds.
		make thread wait until anothrer thread calls notify() on the same object .
		make call inside synchronized method or class


sleep () : should call to therad.
			pause the thread for miliseconds
			doent release any locks, thread might be hold.